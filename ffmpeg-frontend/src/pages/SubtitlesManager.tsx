import { useState, useEffect } from "react";
import { MainLayout } from "@/components/layout/MainLayout";
import FileUploader from "@/components/shared/FileUploader";
import FFmpegCommandDisplay from "@/components/shared/FFmpegCommandDisplay"; // Added back
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Label } from "@/components/ui/label";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Input } from "@/components/ui/input";
import { RadioGroup, RadioGroupItem } from "@/components/ui/radio-group";
import { Button } from "@/components/ui/button"; // Import Button
import { Loader2 } from "lucide-react"; // Import Loader2 icon
import { useFFmpegProcessor } from "@/hooks/useFFmpegProcessor"; // Import the new hook
import OutputMediaPlayer from "@/components/shared/OutputMediaPlayer"; // Import the new component
import { toast } from "sonner"; // Import toast
import type { SingleFileCommandPayload } from "@/hooks/useFFmpegProcessor"; // Import payload type


const SubtitlesManager = () => {
  // Use the new hook
  const {
    selectedFiles, // Keep selectedFiles from hook for UI logic
    uploadedFilename, // Keep for potential display/debugging, but logic relies on return values from upload functions
    outputFile,
    isUploading,
    isProcessing,
    mediaError,
    generatedCommand, // Get the generated command from the hook
    handleFileSelect, // Use the hook's file select handler
    runCommand, // Use the hook's run command handler
    setCommand, // Use the hook's set command function
    setMediaError, // Pass the hook's setMediaError to the player
    uploadSingleFile, // Import the explicit upload function
  } = useFFmpegProcessor();

  const [subtitleFile, setSubtitleFile] = useState<File | null>(null);
  const [actionType, setActionType] = useState<"burn-in" | "extract" | "remove" | "">("");
  const [uploadedSubtitleFilename, setUploadedSubtitleFilename] = useState<string | null>(null); // State for uploaded subtitle file name


  // Effect to generate command string for display whenever selectedFiles, actionType, or subtitleFile changes
  // This command string uses the *local* file names for display purposes.
  useEffect(() => {
      if (selectedFiles.length === 1 && actionType) {
          generateDisplayCommandString(selectedFiles[0].name, subtitleFile, actionType);
      } else {
          setCommand(""); // Clear command if requirements aren't met
      }
  }, [selectedFiles, subtitleFile, actionType, setCommand]); // Add setCommand to dependencies


  const handleSubtitleFileChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    if (event.target.files && event.target.files.length > 0) {
      const file = event.target.files[0];
      setSubtitleFile(file);
      setUploadedSubtitleFilename(null); // Clear uploaded name until upload happens
      console.log("Selected subtitle file:", file);
      // Command will be regenerated by the useEffect hook
    } else {
        setSubtitleFile(null);
        setUploadedSubtitleFilename(null); // Clear uploaded name
        // Command will be regenerated by the useEffect hook
    }
  };

  const handleActionChange = (value: "burn-in" | "extract" | "remove") => {
    setActionType(value);
    // Command will be regenerated by the useEffect hook
  };

  // Function to generate the command string for display (used by useEffect)
  // This uses the *local* file names for display purposes.
  const generateDisplayCommandString = (inputFilename: string, subFile: File | null, action: "burn-in" | "extract" | "remove" | "") => {
    if (!inputFilename || !action) {
      return ""; // Return empty string if command cannot be generated
    }

    const baseName = inputFilename.split('.')[0];
    let command = `ffmpeg -i "${inputFilename}"`;
    let outputFileName = "";

    if (action === "burn-in") {
      if (!subFile) {
        setCommand("Select a subtitle file to burn-in.");
        return ""; // Cannot generate command without subtitle file
      }
      const subtitleFileName = subFile.name;
      // Note: For complex paths or special characters in subtitle file name,
      // the subtitles filter might need escaping or a specific format.
      // This is a basic example.
      outputFileName = `${baseName}_burned-in.${inputFilename.split('.').pop()}`;
      command += ` -vf subtitles='${subtitleFileName}' "${outputFileName}"`;
    } else if (action === "extract") {
       // Note: Extraction typically works best with container formats like MKV that support subtitle streams.
       // This command assumes the first subtitle stream (0:s:0).
       outputFileName = `${baseName}.srt`; // Assuming SRT output
       command = `ffmpeg -i "${inputFilename}" -map 0:s:0 "${outputFileName}"`;
    } else if (action === "remove") {
       // -sn removes all subtitle streams
       outputFileName = `${baseName}_no-subs.${inputFilename.split('.').pop()}`;
       command += ` -c copy -sn "${outputFileName}"`;
    } else {
        setCommand("");
        return ""; // Should not happen with valid actionType
    }

    setCommand(command); // Set the command using the hook's function
    return command; // Return the generated command string
  };

  // New handler for the Run button
  const handleRunClick = async () => {
      if (selectedFiles.length === 0) {
          toast.warning("Please select a video file first.");
          return;
      }
      if (selectedFiles.length > 1) {
          toast.warning("Subtitles Management currently only supports a single video file. Please select only one file.");
          return;
      }
      if (!actionType) {
          toast.warning("Please select an action (Burn-in, Extract, or Remove).");
          return;
      }
      if (actionType === "burn-in" && !subtitleFile) {
          toast.warning("Please upload a subtitle file for burn-in.");
          return;
      }

      // Explicitly trigger single file upload for the main video file
      const uploadedVideoFile = await uploadSingleFile(selectedFiles[0]);

      if (!uploadedVideoFile) {
          // Upload failed, stop here
          return;
      }

      let uploadedSubFile = null;
      if (actionType === "burn-in" && subtitleFile) {
          // Explicitly trigger single file upload for the subtitle file if needed
          uploadedSubFile = await uploadSingleFile(subtitleFile);
          if (!uploadedSubFile) {
              // Subtitle upload failed, stop here
              return;
          }
          setUploadedSubtitleFilename(uploadedSubFile); // Store uploaded subtitle name
      }


      // Construct the actual command payload using the *uploaded* filenames
      const baseName = uploadedVideoFile.split('.')[0];
      let actualCommand = `ffmpeg -i "${uploadedVideoFile}"`;
      let outputFileName = "";

      if (actionType === "burn-in") {
          // Use the uploaded subtitle filename in the command
          outputFileName = `${baseName}_burned-in.${uploadedVideoFile.split('.').pop()}`;
          // Ensure the path to the subtitle file is correct on the backend side
          // Assuming backend serves uploaded files from a known location or handles paths
          actualCommand += ` -vf subtitles='${uploadedSubFile}' "${outputFileName}"`;
      } else if (actionType === "extract") {
         outputFileName = `${baseName}.srt`; // Assuming SRT output
         actualCommand = `ffmpeg -i "${uploadedVideoFile}" -map 0:s:0 "${outputFileName}"`;
      } else if (actionType === "remove") {
         outputFileName = `${baseName}_no-subs.${uploadedVideoFile.split('.').pop()}`;
         actualCommand += ` -c copy -sn "${outputFileName}"`;
      } else {
          toast.error("Invalid action type selected.");
          return;
      }


      const payload: SingleFileCommandPayload = {
          command: actualCommand,
          inputFile: uploadedVideoFile, // Use the main uploaded filename
      };
      runCommand(payload); // Run the command via the hook
  };


  return (
    <MainLayout>
      <div className="flex-1 space-y-4 p-8 pt-6">
        <h2 className="text-3xl font-bold tracking-tight">Subtitles Management</h2>
        <p className="text-muted-foreground">Add, extract, or remove subtitles from videos.</p>

        {/* Use the hook's file select handler */}
        <FileUploader onFileSelect={handleFileSelect} />

        {selectedFiles.length > 0 && ( // Use hook's selectedFiles for UI visibility
          <Card className="w-full">
            <CardHeader>
              <CardTitle>Subtitle Options</CardTitle>
            </CardHeader>
            <CardContent className="space-y-4">

               {isUploading && (
                   <p className="text-sm text-blue-600">Uploading file(s)...</p>
               )}

               {/* Render options only after initial file selection and not uploading */}
               {!isUploading && selectedFiles.length > 0 && (
                   <>
                       {/* Display selected files */}
                       <div>
                           <h4 className="text-md font-semibold mb-2">Selected File(s):</h4>
                           <ul>
                               {selectedFiles.map((file, index) => (
                                   <li key={index} className="text-sm text-muted-foreground">{file.name}</li>
                               ))}
                           </ul>
                       </div>

                       {selectedFiles.length > 1 && (
                           <p className="text-sm text-yellow-600">Note: Subtitles Management currently only supports a single video file. Only the first file will be processed.</p>
                       )}

                       <div className="grid w-full max-w-sm items-center gap-1.5">
                         <Label>Action</Label>
                         <RadioGroup value={actionType} onValueChange={(value: "burn-in" | "extract" | "remove") => handleActionChange(value)} disabled={isProcessing || isUploading}>
                           <div className="flex items-center space-x-2">
                             <RadioGroupItem value="burn-in" id="burn-in" disabled={isProcessing || isUploading} />
                             <Label htmlFor="burn-in">Burn-in Subtitles</Label>
                           </div>
                            <div className="flex items-center space-x-2">
                             <RadioGroupItem value="extract" id="extract" disabled={isProcessing || isUploading} />
                             <Label htmlFor="extract">Extract Subtitles</Label>
                           </div>
                            <div className="flex items-center space-x-2">
                             <RadioGroupItem value="remove" id="remove" disabled={isProcessing || isUploading} />
                             <Label htmlFor="remove">Remove Subtitles</Label>
                           </div>
                         </RadioGroup>
                       </div>

                       {actionType === "burn-in" && (
                          <div className="grid w-full max-w-sm items-center gap-1.5">
                            <Label htmlFor="subtitle-file">Upload Subtitle File (.srt, .ass, etc.)</Label>
                            <Input id="subtitle-file" type="file" onChange={handleSubtitleFileChange} accept=".srt,.ass,.ssa,.vtt" disabled={isProcessing || isUploading} />
                             {subtitleFile && (
                                 <p className="text-sm text-muted-foreground">Selected: {subtitleFile.name}</p>
                             )}
                          </div>
                       )}
                        {actionType === "extract" && (
                            <p className="text-sm text-yellow-600">Note: Extraction typically works best with container formats like MKV that embed subtitle streams.</p>
                        )}
                         {actionType === "remove" && (
                            <p className="text-sm text-yellow-600">Note: This will remove all subtitle streams from the file.</p>
                        )}

                       {/* Run Button - uses the new handleRunClick */}
                       <Button
                           onClick={handleRunClick} // Use the new handler
                           disabled={!actionType || (actionType === "burn-in" && !subtitleFile) || selectedFiles.length === 0 || isProcessing || isUploading} // Disable if options not selected, no file, processing, or uploading
                       >
                           {isProcessing ? (
                               <>
                                   <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                                   Processing...
                               </>
                           ) : isUploading ? (
                               <>
                                   <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                                   Uploading...
                               </>
                           ) : (
                               `Run ${actionType === 'burn-in' ? 'Burn-in' : actionType === 'extract' ? 'Extraction' : actionType === 'remove' ? 'Removal' : 'Operation'}`
                           )}
                       </Button>
                       <p className="text-sm text-yellow-600">
                           Note: Clicking "Run" will first upload the selected file(s) and then send the command to your local backend server running on http://localhost:8200.
                           Ensure your backend is running and has access to the selected file(s).
                       </p>
                   </>
               )}

            </CardContent>
          </Card>
        )}

        {/* Use the new OutputMediaPlayer component */}
        <OutputMediaPlayer outputFile={outputFile} mediaError={mediaError} setMediaError={setMediaError} />

        {/* FFmpegCommandDisplay component is now added back */}
        <FFmpegCommandDisplay command={generatedCommand} />

      </div>
    </MainLayout>
  );
};

export default SubtitlesManager;