import { useState, useEffect } from "react";
import { MainLayout } from "@/components/layout/MainLayout";
import FileUploader from "@/components/shared/FileUploader";
import FFmpegCommandDisplay from "@/components/shared/FFmpegCommandDisplay"; // Added back
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Label } from "@/components/ui/label";
import { Input } from "@/components/ui/input";
import { Slider } from "@/components/ui/slider"; // Assuming Slider is available
import { Button } from "@/components/ui/button"; // Import Button
import { Loader2, Copy } from "lucide-react";
import { useFFmpegProcessor } from "@/hooks/useFFmpegProcessor"; // Import the new hook
import OutputMediaPlayer from "@/components/shared/OutputMediaPlayer"; // Keep for consistency, though no media output
import { toast } from "sonner"; // Import toast
import type { SingleFileCommandPayload } from "@/hooks/useFFmpegProcessor"; // Import payload type


const SceneDetector = () => {
  // Use the new hook
  const {
    selectedFiles, // Keep selectedFiles from hook for UI logic
    uploadedFilename, // Keep for potential display/debugging, but logic relies on return values from upload functions
    outputFile, // Keep for consistency, though no media output
    commandOutput,
    isUploading,
    isProcessing,
    mediaError, // Keep for consistency
    generatedCommand, // Get the generated command from the hook
    handleFileSelect, // Use the hook's file select handler
    runCommand, // Use the hook's run command handler
    setCommand, // Use the hook's set command function
    setMediaError, // Keep for consistency
    uploadSingleFile, // Import the explicit upload function
  } = useFFmpegProcessor();

  const [sensitivity, setSensitivity] = useState<number[]>([60]); // Default sensitivity 0.6 (FFmpeg uses 0-1)

  // Effect to generate command string for display whenever selectedFiles or sensitivity changes
  // This command string uses the *local* file name for display purposes.
  useEffect(() => {
      if (selectedFiles.length === 1) {
          generateDisplayCommandString(selectedFiles[0].name, sensitivity[0] / 100);
      } else {
          setCommand(""); // Clear command if requirements aren't met
      }
  }, [selectedFiles, sensitivity, setCommand]); // Add setCommand to dependencies


  const handleSensitivityChange = (value: number[]) => {
    setSensitivity(value);
    // Command will be regenerated by the useEffect hook
  };

  // Function to generate the command string for display (used by useEffect)
  // This uses the *local* file name for display purposes.
  const generateDisplayCommandString = (inputFilename: string, sensitivityValue: number) => {
    if (!inputFilename) {
      return ""; // Return empty string if command cannot be generated
    }

    // Use the select filter with 'scene' expression
    // The 'showinfo' filter is often used to output frame details including scene score
    // The output of this command goes to stderr/stdout, not a file directly showing scenes.
    const command = `ffmpeg -i "${inputFilename}" -vf "select='gt(scene,${sensitivityValue.toFixed(2)})',showinfo" -f null -`;

    setCommand(command); // Set the command using the hook's function
    return command; // Return the generated command string
  };

  // New handler for the Run button
  const handleRunClick = async () => {
      if (selectedFiles.length === 0) {
          toast.warning("Please select a file first.");
          return;
      }
      if (selectedFiles.length > 1) {
          toast.warning("Scene Detection currently only supports a single file. Please select only one file.");
          return;
      }

      // Explicitly trigger single file upload
      const uploadedFile = await uploadSingleFile(selectedFiles[0]);

      if (uploadedFile) {
          // Construct the actual command payload using the *uploaded* filename
          const actualCommand = generateDisplayCommandString(uploadedFile, sensitivity[0] / 100); // Reuse logic, but pass uploadedFile

          const payload: SingleFileCommandPayload = {
              command: actualCommand,
              inputFile: uploadedFile, // Use the uploaded filename
          };
          // Note: ffprobe output goes to stdout/stderr, not a file.
          // The backend should capture and potentially return this output.
          // For now, the backend just runs the command.
          runCommand(payload); // Run the command via the hook
      }
  };


//   function parseSceneOutput(ffmpegOutput: string | undefined): string {
//   if (!ffmpegOutput) return "No scene changes detected.";

//   const sceneLineRegex = /^\[Parsed_showinfo[^\]]*]\s+n:\s*(\d+)[^\n]*pts_time:([0-9.]+)[^\n]*$/gm;
//   let match: RegExpExecArray | null;
//   const scenes: any[] = [];

//   while ((match = sceneLineRegex.exec(ffmpegOutput)) !== null) {
//     const line = match[0];
//     const frame = parseInt(match[1], 10);
//     const time = parseFloat(match[2]);

//     // Extract only what's needed for output
//     let duration: number | undefined = undefined;
//     let m = /duration_time:([0-9.]+)/.exec(line);
//     if (m) duration = parseFloat(m[1]);

//     let type: string | undefined = undefined;
//     m = /i:([A-Z])/.exec(line);
//     if (m) type = m[1];

//     let mean: number[] | undefined = undefined;
//     m = /mean:\[([0-9 ]+)\]/.exec(line);
//     if (m) mean = m[1].trim().split(" ").map(Number);

//     let stdev: number[] | undefined = undefined;
//     m = /stdev:\[([0-9. ]+)\]/.exec(line);
//     if (m) stdev = m[1].trim().split(" ").map(Number);

//     scenes.push({ frame, time, duration, type, mean, stdev });
//   }

//   if (scenes.length === 0) return "No scene changes detected.";

//   return scenes.map((scene, idx) => {
//     let out = `Scene ${idx + 1}: Frame ${scene.frame}, Time ${scene.time.toFixed(2)}s`;
//     const enrich: string[] = [];
//     if (scene.duration !== undefined) enrich.push(`Duration: ${scene.duration.toFixed(3)}s`);
//     if (scene.type) enrich.push(`Type: ${scene.type}`);
//     if (scene.mean) enrich.push(`Mean YUV: ${scene.mean.join(", ")}`);
//     if (scene.stdev) enrich.push(`Stdev YUV: ${scene.stdev.join(", ")}`);
//     if (enrich.length) out += `\n${enrich.join("  |  ")}`;
//     return out;
//   }).join('\n\n');
// }

// // YUV (ITU-R BT.601 standard) to RGB conversion
// function yuvToRgb(y: number, u: number, v: number): [number, number, number] {
//   // Y in [0,255], U/V in [0,255], but U/V in ffmpeg are centered at 128
//   // Clamp output to [0,255]
//   const r = Math.round(y + 1.402 * (v - 128));
//   const g = Math.round(y - 0.344136 * (u - 128) - 0.714136 * (v - 128));
//   const b = Math.round(y + 1.772 * (u - 128));
//   return [
//     Math.max(0, Math.min(255, r)),
//     Math.max(0, Math.min(255, g)),
//     Math.max(0, Math.min(255, b))
//   ];
// }

// const parsedScenes = parseSceneOutput(commandOutput);

// function enrichScenesColor(ffmpegOutput: string | undefined) {
//   if (!ffmpegOutput) return [];

//   const sceneRegex = /\[Parsed_showinfo.*\] n:\s*(\d+)\s+pts:[^ ]+\s+pts_time:([0-9.]+)\s+duration:[^ ]+\s+duration_time:([0-9.]+).*?fmt:[^ ]+\s+cl:([a-zA-Z]+).*?i:([A-Z])\s+iskey:(\d)\s+type:([A-Z]).*?mean:\[([0-9 ]+)\]\s+stdev:\[([0-9. ]+)\]/g;
//   let match;
//   const scenes = [];

//   while ((match = sceneRegex.exec(ffmpegOutput)) !== null) {
//     const meanYuv = match[8].split(" ").map(Number);
//     const meanRgb = meanYuv.length === 3 ? yuvToRgb(meanYuv[0], meanYuv[1], meanYuv[2]) : [0, 0, 0];

//     scenes.push({
//       frame: parseInt(match[1], 10),
//       time: parseFloat(match[2]),
//       duration: parseFloat(match[3]),
//       frameType: match[5],
//       isKeyframe: match[6] === "1",
//       type: match[7],
//       meanYuv,
//       meanRgb,
//       stdev: match[9].split(" ").map(Number),
//     });
//   }

//   return scenes;
// }

// const finalScenes = enrichScenesColor(parsedScenes);


// Copy handler for the raw FFmpeg output

function yuvToRgb(y: number, u: number, v: number): [number, number, number] {
  const r = Math.round(y + 1.402 * (v - 128));
  const g = Math.round(y - 0.344136 * (u - 128) - 0.714136 * (v - 128));
  const b = Math.round(y + 1.772 * (u - 128));
  return [
    Math.max(0, Math.min(255, r)),
    Math.max(0, Math.min(255, g)),
    Math.max(0, Math.min(255, b))
  ];
}

function parseFfmpegScenes(ffmpegOutput: string | undefined) {
  if (!ffmpegOutput) return [];
  // Updated regex: robust for showinfo output, single line per scene.
  const sceneLineRegex = /^\[Parsed_showinfo[^\]]*]\s+n:\s*(\d+)[^\n]*pts_time:([0-9.]+)[^\n]*duration_time:([0-9.]+)[^\n]*i:([A-Z])[^\n]*mean:\[([0-9 ]+)\][^\n]*stdev:\[([0-9. ]+)\]/gm;
  let match: RegExpExecArray | null;
  const scenes = [];
  while ((match = sceneLineRegex.exec(ffmpegOutput)) !== null) {
    const frame = parseInt(match[1], 10);
    const time = parseFloat(match[2]);
    const duration = parseFloat(match[3]);
    const type = match[4];
    const meanYuv = match[5].trim().split(" ").map(Number);
    const stdev = match[6].trim().split(" ").map(Number);
    const meanRgb = meanYuv.length === 3 ? yuvToRgb(meanYuv[0], meanYuv[1], meanYuv[2]) : [0, 0, 0];

    scenes.push({ frame, time, duration, type, meanYuv, meanRgb, stdev });
  }
  return scenes;
}

const handleCopy = () => {
  if (
    typeof commandOutput === "string" &&
    commandOutput &&
    !commandOutput.startsWith("Error:")
  ) {
    navigator.clipboard.writeText(commandOutput)
      .then(() => toast.success("FFmpeg output copied to clipboard!"))
      .catch((err) => {
        console.error("Failed to copy output: ", err);
        toast.error("Failed to copy output.");
      });
  } else {
    toast("No valid output to copy.");
  }
};

const parsedScenes = parseFfmpegScenes(commandOutput);

  return (
    <MainLayout>
      <div className="flex-1 space-y-4 p-8 pt-6">
        <h2 className="text-3xl font-bold tracking-tight">Scene Detection</h2>
        <p className="text-muted-foreground">Generate FFmpeg commands to detect scene changes in a video.</p>

        {/* Use the hook's file select handler */}
        <FileUploader onFileSelect={handleFileSelect} />

        {commandOutput && (
          <Card className="mt-4">
            <CardHeader className="flex flex-row items-center justify-between">
              <CardTitle>Scene Changes</CardTitle>
              <Button
                size="sm"
                variant="ghost"
                onClick={handleCopy}
                disabled={!commandOutput || commandOutput.startsWith("Error:")}
                aria-label="Copy raw FFmpeg output"
              >
                <Copy className="h-4 w-4" />
              </Button>
            </CardHeader>
            <CardContent>
              <h4 className="font-semibold mb-2">Detected Scenes</h4>
              <pre className="text-xs whitespace-pre-wrap max-h-96 overflow-auto">
                {parsedScenes.length === 0
                  ? <div>No scene changes detected.</div>
                  : parsedScenes.map((scene, idx) => (
                      <div key={idx} style={{ marginBottom: 18 }}>
                        {/* Scene Header: bold and larger */}
                        {/* <div style={{ fontWeight: 700, fontSize: 18, marginBottom: 2 }}>
                          Scene {idx + 1}: Frame {scene.frame}, Time {scene.time.toFixed(2)}s
                        </div> */}
                        <div style={{ fontSize: 17, marginBottom: 2 }}>
                          <span style={{ fontWeight: 700 }}>Scene</span> {idx + 1}:&nbsp;
                          <span style={{ fontWeight: 700 }}>Frame</span> {scene.frame},&nbsp;
                          <span style={{ fontWeight: 700 }}>Time</span> {scene.time.toFixed(2)}s
                        </div>
                        {/* Details: regular font, not bold, smaller size */}
                        <div style={{ display: 'flex', alignItems: 'center', fontSize: 15, fontWeight: 400 }}>
                          Duration: {scene.duration.toFixed(3)}s&nbsp;|&nbsp;
                          Type: {scene.type}&nbsp;|&nbsp;
                          Mean YUV: {scene.meanYuv.join(', ')}
                          {/* Color box after Mean YUV */}
                          <span
                            style={{
                              display: 'inline-block',
                              width: 20,
                              height: 20,
                              marginLeft: 8,
                              marginRight: 8,
                              background: `rgb(${scene.meanRgb.join(',')})`,
                              border: '1px solid #333',
                              verticalAlign: 'middle',
                              borderRadius: 3
                            }}
                            title={`RGB: ${scene.meanRgb.join(',')}`}
                          />
                          |&nbsp;Stdev YUV: {scene.stdev.join(', ')}
                        </div>
                      </div>
                    ))
                }
              </pre>
              <details className="mt-4">
                <summary className="cursor-pointer text-blue-600">Show Raw FFmpeg Output</summary>
                <pre className="text-xs whitespace-pre-wrap max-h-96 overflow-auto mt-2">
                  {commandOutput}
                </pre>
              </details>
            </CardContent>
          </Card>
        )}


        {selectedFiles.length > 0 && ( // Use hook's selectedFiles for UI visibility
          <Card className="w-full">
            <CardHeader>
              <CardTitle>Detection Options</CardTitle>
            </CardHeader>
            <CardContent className="space-y-4">

               {isUploading && (
                   <p className="text-sm text-blue-600">Uploading file...</p>
               )}

               {/* Render options only after initial file selection and not uploading */}
               {!isUploading && selectedFiles.length > 0 && (
                   <>
                       {/* Display selected files */}
                       <div>
                           <h4 className="text-md font-semibold mb-2">Selected File(s):</h4>
                           <ul>
                               {selectedFiles.map((file, index) => (
                                   <li key={index} className="text-sm text-muted-foreground">{file.name}</li>
                               ))}
                           </ul>
                       </div>

                       {selectedFiles.length > 1 && (
                           <p className="text-sm text-yellow-600">Note: Scene detection currently only applies to one file at a time.</p>
                       )}

                       <div className="grid w-full max-w-sm items-center gap-1.5">
                         <Label htmlFor="sensitivity-slider">Sensitivity ({sensitivity[0] / 100})</Label>
                         <Slider
                           id="sensitivity-slider"
                           min={0}
                           max={100}
                           step={1}
                           value={sensitivity}
                           onValueChange={handleSensitivityChange}
                           className="w-full max-w-sm"
                           disabled={isProcessing || isUploading}
                         />
                         <p className="text-sm text-muted-foreground">Use 0 for every frame, or 1 for the fewest scenes</p>
                       </div>

                       {/* Run Button - uses the new handleRunClick */}
                       <Button
                           onClick={handleRunClick} // Use the new handler
                           disabled={selectedFiles.length === 0 || isProcessing || isUploading} // Disable if no file, processing, or uploading
                       >
                           {isProcessing ? (
                               <>
                                   <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                                   Processing...
                               </>
                           ) : isUploading ? (
                               <>
                                   <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                                   Uploading...
                               </>
                           ) : (
                               "Run Detection"
                           )}
                       </Button>
                       <p className="text-sm text-yellow-600">
                           Note: Clicking "Run" will first upload the selected file and then send the command to your local backend server running on http://localhost:8200.
                           Ensure your backend is running and has access to the selected file and FFmpeg. The output (timestamps of scene changes) will be printed to the console/terminal where you execute the command.
                       </p>
                   </>
               )}

            </CardContent>
          </Card>
        )}

        {/* Use the new OutputMediaPlayer component */}
        {/* <OutputMediaPlayer outputFile={outputFile} mediaError={mediaError} setMediaError={setMediaError} /> */}

        {/* FFmpegCommandDisplay component is now added back */}
        <FFmpegCommandDisplay command={generatedCommand} />

      </div>
    </MainLayout>
  );
};

export default SceneDetector;