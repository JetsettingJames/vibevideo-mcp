import { useState, useEffect } from "react";
import { MainLayout } from "@/components/layout/MainLayout";
import FileUploader from "@/components/shared/FileUploader";
import FFmpegCommandDisplay from "@/components/shared/FFmpegCommandDisplay"; // Added back
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Label } from "@/components/ui/label";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button"; // Import Button
import { Loader2 } from "lucide-react"; // Import Loader2 icon
import { useFFmpegProcessor } from "@/hooks/useFFmpegProcessor"; // Import the new hook
import OutputMediaPlayer from "@/components/shared/OutputMediaPlayer"; // Keep for consistency, though output is segments
import { toast } from "sonner"; // Import toast
import type { SingleFileCommandPayload } from "@/hooks/useFFmpegProcessor"; // Import payload type


const Segmenter = () => {
  // Use the new hook
  const {
    selectedFiles, // Keep selectedFiles from hook for UI logic
    uploadedFilename, // Keep for potential display/debugging, but logic relies on return values from upload functions
    outputFile, // Keep for consistency, though output is segments
    isUploading,
    isProcessing,
    mediaError, // Keep for consistency
    generatedCommand, // Get the generated command from the hook
    handleFileSelect, // Use the hook's file select handler
    runCommand, // Use the hook's run command handler
    setCommand, // Use the hook's set command function
    setMediaError, // Keep for consistency
    uploadSingleFile, // Import the explicit upload function
  } = useFFmpegProcessor();
  const [segmentResult, setSegmentResult] = useState<any>(null);

  const [segmentDuration, setSegmentDuration] = useState<string>("10"); // Default to 10 seconds

  // Effect to generate command string for display whenever selectedFiles or segmentDuration changes
  // This command string uses the *local* file name for display purposes.
  useEffect(() => {
      if (selectedFiles.length === 1 && segmentDuration && parseInt(segmentDuration) > 0) {
          generateDisplayCommandString(selectedFiles[0].name, segmentDuration);
      } else {
          setCommand(""); // Clear command if requirements aren't met
      }
  }, [selectedFiles, segmentDuration, setCommand]); // Add setCommand to dependencies

  const handleFileSelectAndClear = (files: File[]) => {
    setSegmentResult(null);
    handleFileSelect(files);
  };

  const handleDurationChange = (value: string) => {
    setSegmentDuration(value);
    // Command will be regenerated by the useEffect hook
  };

  // Function to generate the command string for display (used by useEffect)
  // This uses the *local* file name for display purposes.
  const generateDisplayCommandString = (inputFilename: string, duration: string) => {
    if (!inputFilename || !duration || parseInt(duration) <= 0) {
      return ""; // Return empty string if command cannot be generated
    }

    const baseName = inputFilename.split('.')[0];
    // Output filename for the HLS master playlist
    const outputFileName = `${baseName}.m3u8`;

    // Basic command for HLS segmentation
    // -hls_time: Segment duration in seconds
    // -hls_list_size 0: Keep all segments in the playlist (for VOD)
    // -f hls: Output format is HLS
    // -c copy: Attempt to copy streams if compatible (fastest)
    const command = `ffmpeg -i "${inputFilename}" -c copy -hls_time ${duration} -hls_list_size 0 -f hls "${outputFileName}"`;

    setCommand(command); // Set the command using the hook's function
    return command; // Return the generated command string
  };

  // New handler for the Run button
  const handleRunClick = async () => {
      if (selectedFiles.length === 0) {
          toast.warning("Please select a file first.");
          return;
      }
      if (selectedFiles.length > 1) {
          toast.warning("Adaptive Streaming Segmenter currently only supports a single file. Please select only one file.");
          return;
      }
      if (!segmentDuration || parseInt(segmentDuration) <= 0) {
          toast.warning("Please enter a valid segment duration (greater than 0).");
          return;
      }

      // Explicitly trigger single file upload
      const uploadedFile = await uploadSingleFile(selectedFiles[0]);

      if (uploadedFile) {
          // Construct the actual command payload using the *uploaded* filename
          const actualCommand = generateDisplayCommandString(uploadedFile, segmentDuration); // Reuse logic, but pass uploadedFile

          const payload: SingleFileCommandPayload = {
              command: actualCommand,
              inputFile: uploadedFile, // Use the uploaded filename
          };

          
          // Note: Segmentation outputs multiple files (.ts segments and .m3u8 playlist).
          // The backend should handle this output structure.
          // runCommand(payload); // Run the command via the hook
    await runSegmentation(uploadedFile, Number(segmentDuration));
      }
  };

const runSegmentation = async (filename: string, segmentDuration: number) => {
  setSegmentResult(null); // clear prior result
  const resp = await fetch("http://localhost:8200/run", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      operation: "segment_hls",
      inputFile: filename,
      segmentDuration,
    }),
  });
  const result = await resp.json();
  setSegmentResult(result);
  if (!result.success) {
    toast.error("Segmentation failed.");
  }
};

  return (
    <MainLayout>
      <div className="flex-1 space-y-4 p-8 pt-6">
        <h2 className="text-3xl font-bold tracking-tight">Adaptive Streaming Segmenter</h2>
        <p className="text-muted-foreground">Generate FFmpeg commands to segment media for HLS or DASH.</p>

        {/* Use the hook's file select handler */}
      <FileUploader onFileSelect={handleFileSelectAndClear} />

      {segmentResult && (
        <div className="mt-6">
          <div className={`text-base font-semibold ${segmentResult.success ? "text-green-700" : "text-red-700"}`}>
            {segmentResult.success ? "Segmentation succeeded." : "Segmentation failed."}
          </div>
          <pre className="bg-muted text-xs p-3 rounded whitespace-pre-wrap max-h-72 overflow-y-auto mt-2">
            {segmentResult.output}
          </pre>
          {segmentResult.success && segmentResult.output_file && (
            <div className="mt-3">
              <a
                href={`http://localhost:8200/files/${segmentResult.output_file}`}
                target="_blank"
                className="text-blue-700 underline"
              >
                View HLS playlist ({segmentResult.output_file})
              </a>
            </div>
          )}
        </div>
      )}
        {selectedFiles.length > 0 && ( // Use hook's selectedFiles for UI visibility
          <Card className="w-full">
            <CardHeader>
              <CardTitle>Segmentation Options</CardTitle>
            </CardHeader>
            <CardContent className="space-y-4">

               {isUploading && (
                   <p className="text-sm text-blue-600">Uploading file...</p>
               )}

               {/* Render options only after initial file selection and not uploading */}
               {!isUploading && selectedFiles.length > 0 && (
                   <>
                       {/* Display selected files */}
                       <div>
                           <h4 className="text-md font-semibold mb-2">Selected File(s):</h4>
                           <ul>
                               {selectedFiles.map((file, index) => (
                                   <li key={index} className="text-sm text-muted-foreground">{file.name}</li>
                               ))}
                           </ul>
                       </div>

                       {selectedFiles.length > 1 && (
                           <p className="text-sm text-yellow-600">Note: Adaptive Streaming Segmenter currently only supports a single file. Only the first file will be processed.</p>
                       )}

                       <div className="grid w-full max-w-sm items-center gap-1.5">
                         <Label htmlFor="segment-duration">Segment Duration (seconds)</Label>
                         <Input
                           id="segment-duration"
                           type="number"
                           placeholder="e.g., 10"
                           value={segmentDuration}
                           onChange={(e) => handleDurationChange(e.target.value)}
                           min="1"
                           disabled={isProcessing || isUploading}
                         />
                       </div>

                       {/* Run Button - uses the new handleRunClick */}
                       <Button
                           onClick={handleRunClick} // Use the new handler
                           disabled={!segmentDuration || parseInt(segmentDuration) <= 0 || selectedFiles.length === 0 || isProcessing || isUploading} // Disable if options not selected, no file, processing, or uploading
                       >
                           {isProcessing ? (
                               <>
                                   <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                                   Processing...
                               </>
                           ) : isUploading ? (
                               <>
                                   <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                                   Uploading...
                               </>
                           ) : (
                               "Run Segmentation"
                           )}
                       </Button>
                       <p className="text-sm text-yellow-600">
                           Note: Clicking "Run" will first upload the selected file and then send the command to your local backend server running on http://localhost:8200.
                           Ensure your backend is running and has access to the selected file and FFmpeg. This tool generates a basic HLS segmentation command. Advanced adaptive streaming (multiple bitrates, DASH) requires more complex commands and potentially multiple FFmpeg runs.
                       </p>
                   </>
               )}

            </CardContent>
          </Card>
        )}

        {/* Use the new OutputMediaPlayer component - less relevant here */}
        {/* <OutputMediaPlayer outputFile={outputFile} mediaError={mediaError} setMediaError={setMediaError} /> */}

        {/* FFmpegCommandDisplay component is now added back */}
        <FFmpegCommandDisplay command={generatedCommand} />

      </div>
    </MainLayout>
  );
};

export default Segmenter;