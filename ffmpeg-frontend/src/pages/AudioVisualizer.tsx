import { useState, useEffect } from "react";
import { MainLayout } from "@/components/layout/MainLayout";
import FileUploader from "@/components/shared/FileUploader";
import FFmpegCommandDisplay from "@/components/shared/FFmpegCommandDisplay";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Label } from "@/components/ui/label";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Input } from "@/components/ui/input"; // For size input
import { Button } from "@/components/ui/button";
import { Loader2 } from "lucide-react";
import { useFFmpegProcessor } from "@/hooks/useFFmpegProcessor";
import OutputMediaPlayer from "@/components/shared/OutputMediaPlayer";
import { toast } from "sonner";
import type { SingleFileCommandPayload } from "@/hooks/useFFmpegProcessor";


const AudioVisualizer = () => {
  // Use the new hook
  const {
    selectedFiles, // Keep selectedFiles from hook for UI logic
    uploadedFilename, // Keep for potential display/debugging, but logic relies on return values from upload functions
    outputFile,
    isUploading,
    isProcessing, // Processing state can indicate streaming is attempting to start
    mediaError, // Keep for consistency, though less relevant for streaming command generation
    generatedCommand, // Get the generated command from the hook
    handleFileSelect, // Use the hook's file select handler
    runCommand, // Use the hook's run command handler
    setCommand, // Use the hook's set command function
    setMediaError, // Keep for consistency
    uploadSingleFile, // Import the explicit upload function
  } = useFFmpegProcessor();

  const [visualizationType, setVisualizationType] = useState<"showfreqs" | "aspectrum" | "">("");
  const [vizSize, setVizSize] = useState<string>("1280x720"); // Default output size
  const [vizMode, setVizMode] = useState<string>(""); // Mode parameter, depends on filter type

  const typeOptions = [
    { label: "Select Type", value: "" },
    { label: "Show Frequencies (showfreqs)", value: "showfreqs" },
    { label: "Audio Spectrum (aspectrum)", value: "aspectrum" },
    // Add other video-generating audio filters here if needed
  ];

  // Options for the 'mode' parameter, depends on the selected filter type
  const modeOptions: { [key: string]: { label: string; value: string }[] } = {
      showfreqs: [
          { label: "Select Mode", value: "" },
          { label: "Line", value: "line" },
          { label: "Bar", value: "bar" },
          { label: "Dot", value: "dot" },
          // Add more showfreqs modes
      ],
      aspectrum: [
          { label: "Select Mode", value: "" },
          { label: "Separate", value: "separate" },
          { label: "Combined", value: "combined" },
          // Add more aspectrum modes
      ],
      "": [], // No modes when no type is selected
  };


  // Effect to generate command string for display whenever selectedFiles, type, size, or mode changes
  // This command string uses the *local* file name for display purposes.
  useEffect(() => {
      console.log("[AudioVisualizer] useEffect [command generation] triggered.", { selectedFilesLength: selectedFiles.length, visualizationType, vizSize, vizMode });
      if (selectedFiles.length === 1 && visualizationType && vizSize && vizMode) {
          generateDisplayCommandString(selectedFiles[0].name, visualizationType, vizSize, vizMode);
      } else {
          setCommand(""); // Clear command if requirements aren't met
      }
  }, [selectedFiles, visualizationType, vizSize, vizMode, setCommand]); // Add all dependencies


  const handleTypeChange = (value: "showfreqs" | "aspectrum" | "") => {
    setVisualizationType(value);
    // Reset mode when type changes
    setVizMode("");
    // Command will be regenerated by the useEffect hook
  };

  const handleSizeChange = (event: React.ChangeEvent<HTMLInputElement>) => {
      const newSize = event.target.value;
      setVizSize(newSize);
      // Command will be regenerated by the useEffect hook
  }

  const handleModeChange = (value: string) => {
      setVizMode(value);
      // Command will be regenerated by the useEffect hook
  }


  // Function to generate the command string for display (used by useEffect)
  // This uses the *local* file name for display purposes.
  const generateDisplayCommandString = (inputFilename: string, type: "showfreqs" | "aspectrum" | "", size: string, mode: string) => {
    console.log("[AudioVisualizer] generateDisplayCommandString called", { inputFilename, type, size, mode });

    let command: string; // Declare command here

    if (!inputFilename || !type || !size || !mode) {
      console.log("[AudioVisualizer] generateDisplayCommandString: Missing required parameters, returning empty.");
      setCommand("");
      return ""; // Return empty string if command cannot be generated
    }

    const baseName = inputFilename.split('.')[0];
    // Output as MP4 for browser compatibility
    const outputFileName = `${baseName}_${type}.${'mp4'}`;

    // Build the filter string with parameters
    // Use [0:a] to explicitly select the audio stream from the first input
    const filterString = `${type}=s=${size}:mode=${mode}`;

    // Use -filter_complex to apply the filter and create a new video stream [v]
    // Then map the generated video stream [v] and the original audio stream 0:a
    // Use browser-compatible codecs (libx264 for video, aac for audio)
    command = `ffmpeg -i "${inputFilename}" -filter_complex "[0:a]${filterString}[v]" -map "[v]" -map 0:a -c:v libx264 -c:a aac -strict experimental "${outputFileName}"`; // Assign command here

    console.log("[AudioVisualizer] generateDisplayCommandString: Generated command:", command);
    setCommand(command); // Set the command using the hook's function
    return command; // Return the generated command string
  };

  // New handler for the Run button
  const handleRunClick = async () => {
      console.log("[AudioVisualizer] handleRunClick called.", { selectedFilesLength: selectedFiles.length, visualizationType, vizSize, vizMode });
      if (selectedFiles.length === 0) {
          toast.warning("Please select a file first.");
          return;
      }
      if (selectedFiles.length > 1) {
          toast.warning("Audio Visualization currently only supports a single file. Please select only one file.");
          return;
      }
      if (!visualizationType) {
          toast.warning("Please select a visualization type.");
          return;
      }
      if (!vizSize) {
          toast.warning("Please enter an output size (e.g., 1280x720).");
          return;
      }
      if (!vizMode) {
          toast.warning("Please select a mode for the visualization.");
          return;
      }


      // Explicitly trigger single file upload
      console.log("[AudioVisualizer] handleRunClick: Calling uploadSingleFile...");
      const uploadedFile = await uploadSingleFile(selectedFiles[0]);
      console.log("[AudioVisualizer] handleRunClick: uploadSingleFile returned:", uploadedFile);


      if (uploadedFile) {
          // Construct the actual command payload using the *uploaded* filename
          const actualCommand = generateDisplayCommandString(uploadedFile, visualizationType, vizSize, vizMode); // Reuse logic, but pass uploadedFile
          console.log("[AudioVisualizer] handleRunClick: Actual command generated for backend:", actualCommand);

          // Check if command was successfully generated
          if (!actualCommand) {
              toast.error("Could not generate command. Please check your options.");
              return;
          }

          const payload: SingleFileCommandPayload = {
              command: actualCommand,
              inputFile: uploadedFile, // Use the uploaded filename
          };
          console.log("[AudioVisualizer] handleRunClick: Running command with payload:", payload);
          runCommand(payload); // Run the command via the hook
      }
  };


  return (
    <MainLayout>
      <div className="flex-1 space-y-4 p-8 pt-6">
        <h2 className="text-3xl font-bold tracking-tight">Audio Visualization</h2>
        <p className="text-muted-foreground">Generate visual representations (waveforms, spectrograms) from audio streams.</p>

        {/* Banner/Note */}
        <div className="bg-blue-100 border-l-4 border-blue-500 text-blue-700 p-4" role="alert">
            <p className="font-bold">Note:</p>
            <p className="text-sm">This tool creates a *new video file* showing an animated visualization of the audio, synced with the original audio stream. It does not modify the original video (if any).</p>
        </div>


        {/* Use the hook's file select handler */}
        <FileUploader onFileSelect={handleFileSelect} />

        {selectedFiles.length > 0 && ( // Use hook's selectedFiles for UI visibility
          <Card className="w-full">
            <CardHeader>
              <CardTitle>Visualization Options</CardTitle>
            </CardHeader>
            <CardContent className="space-y-4">

               {isUploading && (
                   <p className="text-sm text-blue-600">Uploading file...</p>
               )}

               {/* Render options only after initial file selection and not uploading */}
               {!isUploading && selectedFiles.length > 0 && (
                   <>
                       {/* Display selected files */}
                       <div>
                           <h4 className="text-md font-semibold mb-2">Selected File(s):</h4>
                           <ul>
                               {selectedFiles.map((file, index) => (
                                   <li key={index} className="text-sm text-muted-foreground">{file.name}</li>
                               ))}
                           </ul>
                       </div>

                       {selectedFiles.length > 1 && (
                           <p className="text-sm text-yellow-600">Note: Visualization currently only applies to the first selected file.</p>
                       )}

                       <div className="grid w-full max-w-sm items-center gap-1.5">
                         <Label htmlFor="viz-type-select">Visualization Type</Label>
                         <Select onValueChange={handleTypeChange} value={visualizationType} disabled={isProcessing || isUploading}>
                           <SelectTrigger id="viz-type-select">
                             <SelectValue placeholder="Select type" />
                           </SelectTrigger>
                           <SelectContent>
                            {typeOptions
                                .filter(option => option.value !== "")
                                .map(option => (
                                <SelectItem key={option.value} value={option.value}>
                                    {option.label}
                                </SelectItem>
                            ))}
                            </SelectContent>

                         </Select>
                       </div>

                       {visualizationType && (
                           <>
                               <div className="grid w-full max-w-sm items-center gap-1.5">
                                   <Label htmlFor="viz-size">Output Size (e.g., 1280x720)</Label>
                                   <Input
                                       id="viz-size"
                                       type="text"
                                       placeholder="WxH"
                                       value={vizSize}
                                       onChange={handleSizeChange}
                                       disabled={isProcessing || isUploading}
                                   />
                               </div>

                               {modeOptions[visualizationType] && modeOptions[visualizationType].length > 0 && (
                                   <div className="grid w-full max-w-sm items-center gap-1.5">
                                       <Label htmlFor="viz-mode-select">Mode</Label>
                                       <Select onValueChange={handleModeChange} value={vizMode} disabled={isProcessing || isUploading}>
                                           <SelectTrigger id="viz-mode-select">
                                               <SelectValue placeholder="Select mode" />
                                           </SelectTrigger>
                                           <SelectContent>
                                            {modeOptions[visualizationType]
                                                ?.filter(option => option.value) // Filter out empty string values
                                                .map(option => (
                                                <SelectItem key={option.value} value={option.value}>
                                                    {option.label}
                                                </SelectItem>
                                            ))}
                                            </SelectContent>

                                       </Select>
                                   </div>
                               )}
                           </>
                       )}


                       {/* Run Button - uses the new handleRunClick */}
                       <Button
                           onClick={handleRunClick} // Use the new handler
                           disabled={!visualizationType || !vizSize || !vizMode || selectedFiles.length === 0 || isProcessing || isUploading} // Disable if options not selected, no file, processing, or uploading
                       >
                           {isProcessing ? (
                               <>
                                   <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                                   Processing...
                               </>
                           ) : isUploading ? (
                               <>
                                   <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                                   Uploading...
                               </>
                           ) : (
                               "Run Visualization"
                           )}
                       </Button>
                       <p className="text-sm text-yellow-600">
                           Note: Clicking "Run" will first upload the selected file and then send the command to your local backend server running on http://localhost:8200.
                           Ensure your backend is running and has access to the selected file.
                       </p>
                       <p className="text-sm text-yellow-600">
                           Note: The generated command uses `-filter_complex` to create a new video stream from the audio and then maps this new video stream along with the original audio stream to the output file.
                       </p>
                   </>
               )}

            </CardContent>
          </Card>
        )}

        {/* Use the new OutputMediaPlayer component */}
        <OutputMediaPlayer outputFile={outputFile} mediaError={mediaError} setMediaError={setMediaError} />

        {/* FFmpegCommandDisplay component is now added back */}
        <FFmpegCommandDisplay command={generatedCommand} />

      </div>
    </MainLayout>
  );
};

export default AudioVisualizer;